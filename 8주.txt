기계 8주차

CNN  : Convolution Neural Network


ANN : 은닉계층이 하나인 뉴런 네트웍

DNN : 은닉계층을 많이 쌓아 만든 인공지능 계층

CNN : 주로 영상처리에 많이 활용되ㅏ는 합성곱을 이용하는 인공 신경망

합성곱은 필터 같은게 있어 필터를 지나다니며 특징을 찾는 것이다.

특징을 찾아 그 합성곱 결과를 다음 계층으로 보낸다.


Convolution
곱해지는 작은 커널들 즉 필터에 따라 값이 달라질 수 있다. 그래서 이것들을 매트릭스의 각 요소들을 곱해 더한것?


Fully connected layer
강의 자료에서 보면
이미지를 1차원으로 쭉 편다. 그러면 3072만큼의 인풋값이 나오는데, 그것에 대한 10개의 w값을 지나게 된다. 그러면 각각의 10개의 클래스의 확률값이 나오는데 제일 높은 값의 인덱스가 값이 된다.

Convolution layer

32*32크기의 이미지와 RGB값인 depth(칼라값)3이 있다. 우리는 이것을 convolution layer을 통하면.

필터는 5*5만큼의 작은 사이즈다. (depth  (채널이라고 함)값이 같아야 한다)
필터 = 커널?

activation map은 이 필터에 의해 결정되는 것이다.

아웃풋 채널의 개수는 convolution fillter의 개수와 같다. 즉 필터를 지날 수록 채널 수가 늘어나는 것이다.

필터와 입력의 계산
입력이 4*4 채널은 1
1개의 필터 3*3 채널은 1
결과 2*2 채널 1

입력 
0 1 2 3
4 5 6 7
8 9 a b
c d e f
라고 할 때 
필터가 3*3이므로
0 1 2
4 5 6 
8 9 a
를 한번 거치고 그다음은
1 2 3
5 6 7
9 a b
를 거치고
4 5 6
8 9 a
c d e
를 거치고 
5 6 7
9 a b
d e f
를 거친다
거칠 때 각 위치가 같은 것을 곱한다 즉 필터가 처음 거치면 (0,0) 부터 (2,2)까지의 부분과 연산을 하는데 인풋의 (0,0)과 필터의 (0,0)
인풋의 (0,1)과 필터의 (0,1) ... 쭉 해 (2,2)와 필터의 (2,2)를 곱한 값을 다 더한다.
이렇게 위에 보면 4번 거치게 되는데 이것을 표로 저장해 내보낸다. 그러면 결국 4번 거치는데 2*2의 크기가 되는 것이다.

채널이 여러개인 경우는 각 채널의 위치까지 같은 것들을 곱해 더하는 것이다. 즉 인풋 2채널이라면 필터 2채널의 값들과 연산을 해 나온 결과들 까지 다 더하는 것이다. (1채널의 결과와 2채널의 결과 까지 다 더하는 것)


stride 
필터가 몇칸씩 이동할 건지 지정하는 것이다.


그런데 이러면 필터가 있는 레이어를 지날 때마다 크기가 점점 줄어든다. 여러번 지나면 결국 1*1의 크기만 남게 되는데 이러면 학습하는데 문제가 생긴다.

이걸 방지하기위해 padding을 사용한다.


zero padding 
양 사방에 0을 넣어 입력과 출력 사이즈를 같게 하는 것이다.

zero padding의 사용을 옵션으로 줄 수 있다.

Same : convolution 후에도 사이즈가 같도록 유지

Valid : convolution 후에 사이즈가 줄어듬


Tensorflow에서의 입력 채널

Data format NHWC기본 
ex- (60000, 28, 28, 1)
§ batch_shape + [height, width, channels].
§ 첫번째 파라미터 : 배치 사이즈
§ 두번재 파라미터 : 가로
§ 세번재 파라키터 : 세로
§ 네번째 파라미터 : 아웃풋 채널


만약 (3,3)의 배열로 이미지 예시를 만들었다고 하자

그런데 convolution의 기본 입력 사이즈는 4차원이다. 그래서 (3,3)이여도 reshape을 통해
(1,3,3,1)로 바꿔 주어야 한다.


conv2d = keras.layers.Conv2D(filters=1, kernel_size=2, padding=option,
kernel_initializer=weight)(image)

이것이 레이어를 만드는 것인데 옵션을 설명하면 

필터는 1개 커널사이즈는 2 패딩은 Valid인지 same인지, 커널 이니셜라지저는 가중치를 의미한다.

레이어 이후 한줄로 결과가 나오기 때문에 reshape으로 그림이 그려지도록 표시한다.


convolution 으로 나온 결과값에 Activation Function을 사용하면 -값은 0으로 바꾸는 등 계속 레이어를 쌓아 나갈수 있다.

convolution은 fillter를 여러개 중첩시킬 수 있다. 그런데 너무 많은 필터와 레이어를 하면 이것 역시 오버피팅이 된다. 

이것을 방지하기 위해 pooling을 사용

max pooling
현재있는 데이터에서 가장 큰값을 사용

average pooling
현재 있는 데이터에서 평균값을 사용

pool_size나 padding등의 옵션을 사용 가능

keras.layers.MaxPooling2D()이런식으로 사용


그래서 큰 틀을 보면
CONV를 사용하고 RELU를 하고 다시 CONV를 하고 RELU를 하며 중간중간에 POOL을 넣어준다. 그리고 마지막은 FC (fully connected)를 사용한다.
그래서 마지막으로 사용한 softmax로 확률 값이 가장 높은 것이 다음 이미지가 무엇인지 결정한다.









